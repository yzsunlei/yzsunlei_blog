<a id="_____"></a><a id="_Toc515962800"></a>《Python爬虫技术 深入理解原理、技术与开发》

[1\.	第1篇 基础知识	1](#_101)

[2\.	第1章 开发环境配置	1](#_102)

[2\.1\.	1、安装官方的Python运行环境	1](#_386)

[2\.1\.1\.	目前常用的操作系统是Windows、macOS和Linux三大平台	1](#_397)

[2\.2\.	2、配置PATH环境变量	1](#_387)

[2\.2\.1\.	为了更方便的执行python命令，建议将Python安装目录添加到PATH环境变量中	1](#_398)

[2\.3\.	3、安装Anaconda Python开发环境	1](#_388)

[2\.3\.1\.	集成的Python运行环境，除了包含Python本身的运行环境外，还集成了很多第三方模块，如numpy、pandas、flask等	1](#_399)

[2\.4\.	4、安装PyCharm	1](#_389)

[2\.4\.1\.	一个专门用于开发Python程序的IDE	1](#_400)

[2\.5\.	5、配置PyCharm	1](#_390)

[3\.	第2章 爬虫基础	1](#_103)

[3\.1\.	1、HTTP基础	1](#_391)

[3\.1\.1\.	URI统一资源标识符，URL是URI的子集，URN统一资源名称，P2P下载中使用的磁力链接是URN的一种实现	1](#_401)

[3\.1\.2\.	在Web应用中，超文本主要是指HTML代码，在浏览器中看到的内容就是浏览器解析超文本后的输出结果	1](#_402)

[3\.1\.3\.	协议指数据传输协议，也就是数据的传输格式（数据传输规范）	1](#_403)

[3\.1\.4\.	HTTP超文本传输协议，理论上可以传输任何类型的数据，包括超文本数据、普通的文本数据、二进制数据（如图像、视频文件等）	2](#_404)

[3\.1\.5\.	HTTPS是安全的HTTP数据通道，可认为是HTTP的安全版本，即HTTP下加入SSL层	2](#_405)

[3\.1\.6\.	在Chrome页面右键菜单中单击”检查“命令打开开发者工具，然后切换到Network面板	2](#_406)

[3\.1\.7\.	详细信息页面有3个部分，General、Response Headers和Request Headers，分别表示基本信息、响应头信息和请求头信息	2](#_407)

[3\.1\.8\.	GET和POST请求方法主要区别：GET请求中的参数都包含在URL中，数据可以在URL中看到，而POST请求提交的数据并不会包含在URL中；GET请求提交的数据最多只有1024个字节，而POST请求对提交数据的大小没有限制	2](#_408)

[3\.1\.9\.	请求头用来提供服务器使用的信息，由若干个请求字段组成，Accept告知客户端可以接收什么类型的信息、Content\-Type请求体的文档类型、Cookie存储在本地的数据、Referer标识这个请求是从哪个页面发过来的、User\-Agent表示客户端的操作系统和浏览器版本	2](#_409)

[3\.1\.10\.	服务端返回给客户端数据称为响应，可分为3部分：响应状态码、响应头、响应体	2](#_410)

[3\.1\.11\.	响应头包含了服务器对请求的应答信息，如Content\-Type、Date、Server等	2](#_411)

[3\.1\.12\.	响应体是服务器对客户端具体的响应数据，可以包含任何格式的内容	2](#_412)

[3\.2\.	2、网页基础	2](#_392)

[3\.2\.1\.	Web三剑客：HTML、CSS和JavaScript	2](#_413)

[3\.2\.2\.	HTML用来描述网页的一种语言，用不同的标记表示各种节点	3](#_414)

[3\.2\.3\.	CSS的主要作用是：将由HTML定义的页面节点安排到合适的位置即布局了；设置页面节点的样式；	3](#_415)

[3\.2\.4\.	CSS的核心是选择器，选择器的作用就是让CSS知道需要设置哪些HTML节点	3](#_416)

[3\.2\.5\.	实现页面特效，或从服务端使用AJAX获取数据并动态显示在Web页面中就需要借助JavaScript	3](#_417)

[3\.3\.	3、爬虫的基本原理	3](#_393)

[3\.3\.1\.	爬虫，主要的功能是下载Internet或局域网中的各种资源	3](#_418)

[3\.3\.2\.	分类：全网爬虫、站内爬虫、定向爬虫	3](#_419)

[3\.3\.3\.	在Python语言中有很多库可以实现从网络上下载资源的功能，如urllib、request等	3](#_420)

[3\.4\.	4、Session与Cookie	3](#_394)

[3\.4\.1\.	静态页面的内容是使用HTML代码编写的，文件中的任何内容都是固定的，除非直接修改文件	3](#_421)

[3\.4\.2\.	动态页面的实现方式非常多，都是由服务端根据不同的条件动态向客户端发送内容	3](#_422)

[3\.4\.3\.	模拟登录的方式很多，其中最常用的方式就是Cookie劫持	3](#_423)

[3\.4\.4\.	HTTP的无状态是指HTTP协议在客户端与服务端交互的过程中不保留状态	3](#_424)

[3\.4\.5\.	Session与Cookies类似，只是将数据保存 服务端	3](#_425)

[3\.4\.6\.	查看Cookie的方式，最简单的就是通过Chrome浏览器开发者工具的Application选项卡	3](#_426)

[3\.5\.	5、实战案例：抓取所有的网络资源	4](#_395)

[3\.5\.1\.	全网爬虫至少有一个入口点，然后爬虫抓取这个入口点指向的页面，接下来将该页面中所有链接节点中href属性的提取出来	4](#_427)

[3\.6\.	6、实战案例：抓取博客文章列表	4](#_396)

[4\.	第2篇 网络库	4](#_104)

[5\.	第3章 网络库urllib	4](#_105)

[5\.1\.	1、urllib简介	4](#_126)

[5\.1\.1\.	urllib包含4个模块：request基本HTTP请求模块；error异常处理模块；parse工具模块；robotparser识别网站robots文件	4](#_147)

[5\.2\.	2、发送请求与获得响应	4](#_127)

[5\.2\.1\.	1\.发送HTTP请求通过urlopen函数就可以搞定	4](#_148)

[5\.2\.2\.	2\.urlopen函数返回的是HTTPResponse类型的对象，主要包含read、getheader、getheaders等方法，以及msg、version、status、debuglevel、closed等属性	4](#_149)

[5\.2\.3\.	3\.发送HTTP POST请求需要使用data命令参数，该参数是bytes类型	4](#_150)

[5\.2\.4\.	4\.请求超时通过urlopen函数的timeout命名参数进行设置，单位为秒	4](#_151)

[5\.2\.5\.	5\.要想色值HTTP请求头，需要为urlopen函数传入Request对象，可以通过Request类构造方法的headers命名参数设置HTTP请求头	4](#_152)

[5\.2\.6\.	6\.有时需要将HTTP请求头的值设为中文，但直接设成中文，会抛出异常。为了解决这个问题，在设置HTTP请求头时需要将中文编码，发送到服务端后，在服务端用同样的规则解码	4](#_153)

[5\.2\.7\.	7\.用户名和密码是通过HTTP请求头的Authrization字段发送给服务端的，所以在访问该页面时可以直接设置Authorization字段	5](#_154)

[5\.2\.8\.	8\.使用ProxyHandler类可以设置HTTP和HTTPS代理	5](#_155)

[5\.2\.9\.	9\.读取Cookie需要创建http\.cookiejar\.CookieJar类的实例传入urllib\.request\.HTTPCookieProcessor类的实例，并将http\.cookiejar\.CookieJar类的实例传入urllib\.request\.HTTPCookieProcessor类的构造方法中	5](#_156)

[5\.3\.	3、异常处理	5](#_128)

[5\.3\.1\.	1\.异常类都在urllib的error模块中定义，主要有两个异常类：URLError和HTTPError	5](#_157)

[5\.3\.2\.	2\.URLError类属于urllib库的error模块，该类从OSError类继承，是error模块中的异常基类，由request模块产生的异常都可以通过URLError来捕获	5](#_158)

[5\.3\.3\.	3\.HTTPError是URLError的子类，专门用于处理HTTP请求错误，比如400、404错误	5](#_159)

[5\.4\.	4、解析链接	5](#_129)

[5\.4\.1\.	1\.urllib库里的parse模块可以用来解析URL	5](#_160)

[5\.4\.2\.	2\.parse模块支持如下协议的URL处理：file、ftp、gopher、hdl、http、https、imap、mailto、mms、news、nntp、prospero、rsync、rtsp、rtspu、sftp、shttp、sip、sips、snews、svn、svn\+ssh、wais、ws、wss	5](#_161)

[5\.4\.3\.	3\.拆分与合并URL（urlparse、urlunparse）；另一种拆分与合并的方式（urlsplit、urlunsplit）；连接URL（urljoin）；URL编码（urlencode）；编码与解码（quote与unquote）；参数转换（parse\_qs与parse\_qsl）	5](#_162)

[5\.5\.	5、Robots协议	6](#_130)

[5\.5\.1\.	1\.Robots协议也称作爬虫协议、机器人协议，它的全名是网络爬虫排除标准，用来告诉爬虫和搜索引擎哪些页面可以抓取，哪些不可以抓取	6](#_163)

[5\.5\.2\.	2\.robots\.txt文件中有2个重要的授权指令：Disallow和Allow，前者表示禁止抓取，后者表示允许抓取	6](#_164)

[5\.5\.3\.	3\.RobotFileParser类的构造方法也可以接收一个URL，然后使用can\_fetch方法判断是否可以抓取某一个页面	6](#_165)

[6\.	第4章 网络库urllib3	6](#_106)

[6\.1\.	1、urllib3简介	6](#_131)

[6\.1\.1\.	1\.urllib主要侧重于URL的请求构造，而urllib2侧重于HTTP请求的处理，而urllib3则是服务于升级的HTTP1\.1标准，且拥有高效HTTP连接池管理及HTTP代理服务的功能库	6](#_166)

[6\.2\.	2、urllib3模块	6](#_132)

[6\.2\.1\.	1\.urllib3提供了很多python标准库里所没有的重要特性，这些特性包括：线程安全；连接池；客户端SSL/TLS验证；使用multipart编码上传文件；协助处理重复请求和HTTP重定位；支持压缩编码；支持HTTP和Socks代理；100%测试覆盖率；	6](#_167)

[6\.3\.	3、发送HTTP GET请求	6](#_133)

[6\.4\.	4、发送HTTP POST请求	6](#_134)

[6\.5\.	5、HTTP请求头	6](#_135)

[6\.5\.1\.	1\.通过PoolManager对象的request方法的headers关键字参数可以指定字典形式的HTTP请求头	6](#_168)

[6\.6\.	6、HTTP响应头	7](#_136)

[6\.7\.	7、上传文件	7](#_137)

[6\.8\.	8、超时	7](#_138)

[6\.8\.1\.	1\.由于HTTP底层是基于Socket实现的，所以连接的过程中也可能超时。Socket超时分为连接超时和读超时	7](#_169)

[7\.	第5章 网络库requests	7](#_107)

[7\.1\.	requests是功能强大且使用方便的Python网络库	7](#_175)

[7\.2\.	1、基本用法	7](#_139)

[7\.2\.1\.	1\.get方法指定的URL不仅可以是网页，还可以是任何二进制文件，如png图像、pdf文档等	7](#_170)

[7\.3\.	2、高级用法	7](#_140)

[7\.3\.1\.	1\.使用requests上传文件是相当简单的，只需指定post方法的files参数即可	7](#_171)

[7\.3\.2\.	2\.requests使用代理非常容易，只需指定proxies参数即可	7](#_172)

[7\.3\.3\.	3\.为了避免抛出异常而导致的程序崩溃，通常的做法是使用try\.\.\.except语句来捕捉超时异常	7](#_173)

[7\.4\.	3、小结	7](#_141)

[7\.4\.1\.	1\.requests使用起来真是太方便了，很多案例都完成了复杂的功能，但代码量却很少	7](#_174)

[8\.	第6章 Twisted网络框架	7](#_108)

[8\.1\.	Twisted是一个完整的事件驱动的网络框架。爬虫框架Scrapy就是使用Twisted框架编写的	7](#_176)

[8\.2\.	1、异步编程模型	8](#_142)

[8\.2\.1\.	1\.目前常用的编程模型有3种：同步编程模型、线程编程模型和异步编程模型	8](#_177)

[8\.2\.2\.	2\.如果要完成多个任务，比较有效的方式是将这些任务分解，然后启动多个线程，每个线程处理一部分任务，最后再将处理结果合并	8](#_178)

[8\.2\.3\.	3\.采用异步编程模型，当一个任务被阻塞后，就会立刻执行另一个任务	8](#_179)

[8\.3\.	2、Reactor（反应堆）模式	8](#_143)

[8\.3\.1\.	1\.这种利用循环体来等待事件发生，然后处理发生的事件的模型被设计成了一个模式：Reactor（反应堆）模式	8](#_180)

[8\.4\.	3、HelloWorld，Twisted框架	8](#_144)

[8\.4\.1\.	1\.用于回调的代码是我们传递给Twisted的	8](#_181)

[8\.5\.	4、用Twisted实现时间戳客户端	8](#_145)

[8\.5\.1\.	1\.Twisted框架的异步机制是整个框架的基础，可以在这个基础上实现很多基于异步编程模型的应用	8](#_182)

[8\.6\.	5、用Twisted实现时间戳服务端	8](#_146)

[9\.	第3篇 解析库	8](#_109)

[10\.	第7章 正则表达式	8](#_110)

[10\.1\.	Python语言内置的功能主要是正则表达式，通过正则表达式，可以对任意字符串进行搜索、分组等复杂操作	8](#_202)

[10\.2\.	1、使用正则表达式	8](#_183)

[10\.2\.1\.	1\.使用match方法匹配字符串，该方法用于指定文本模式和待匹配的字符串	9](#_203)

[10\.2\.2\.	2\.使用search方法在一个字符串中查找模式，该方法用于在一段文本中找到一个或多个与文本模式相匹配的字符串	9](#_204)

[10\.2\.3\.	3\.匹配多个字符串，最简单的方法是在文本模式字符串中使用择一匹配符号（|）	9](#_205)

[10\.2\.4\.	4\.匹配一类字符串的特殊符号：点\(\.\)	9](#_206)

[10\.2\.5\.	5\.使用字符集，某些字符可以有多个选择，就需要使用字符集（\[\]）	9](#_207)

[10\.2\.6\.	6\.重复、可选和特殊字符，要对重复模式进行匹配，就需要使用两个符号："\*"和"\+"	9](#_208)

[10\.2\.7\.	7\.分组，可以通过group方法的参数获取指定的组匹配的字符串	9](#_209)

[10\.2\.8\.	8\.匹配字符串的起始和结尾以及单词边界，"^"符号用于表示匹配字符串的开始，"$"符号用于表示匹配字符串的结束	9](#_210)

[10\.2\.9\.	9\.使用findall和finditer查找每一个出现的位置。findall函数用于查询字符串中某个正则表达式模式全部的非重复出现情况。与match函数和search函数不同之处在于，findall函数总是返回一个包含搜索结果的列表。finditer函数在功能上与findall函数类似，只是更节省内存	9](#_211)

[10\.2\.10\.	10\.用sub和subn搜索与替换，用于实现搜索和替换功能。	9](#_212)

[10\.2\.11\.	11\.使用split分隔字符串。用于根据正则表达式分隔字符串	9](#_213)

[10\.3\.	2、一些常用的正则表达式	9](#_184)

[10\.3\.1\.	1\.Email：'\[0\-9a\-zA\-Z\]\+@\[0\-9a\-zA\-Z\]\+\\\.\[a\-zA\-Z\]\{2,3\}'	9](#_214)

[10\.3\.2\.	2\.IP地址：'\\d\{1,3\}\.\\d\{1,3\}\.\\d\{1,3\}\.\\d\{1,3\}'	9](#_215)

[10\.3\.3\.	3\.Web地址：'https?:/\{2\}\\w\.\+'	10](#_216)

[10\.4\.	6、小结	10](#_185)

[10\.4\.1\.	1\.其实正则表达式并不是解决搜索和匹配问题的唯一方式，有很多现成的库提供了大量的API可以对复杂数据进行搜索和定位	10](#_217)

[11\.	第8章 lxml与XPath	10](#_111)

[11\.1\.	1、lxml基础	10](#_186)

[11\.1\.1\.	1\.lxml是Python的一个解析库，用于解析HTML和XML，支持XPath解析方式	10](#_218)

[11\.1\.2\.	2\.lxml底层是使用C语言编写的，所以解析效率非常高	10](#_219)

[11\.1\.3\.	3\.parse函数返回值是lxml\.etree\.\_ElementTree对象	10](#_220)

[11\.1\.4\.	4\.使用lxml操作HTML的方式与操作XML非常类似	10](#_221)

[11\.2\.	2、XPath	10](#_187)

[11\.2\.1\.	1\.XPath的英文全称是XML Path Language，中文是XML路径语言，是一种XML文档中查找信息的语言，最初 是用于在XML文档中搜索节点的，但同样可用于HTML文档的搜索	10](#_222)

[11\.2\.2\.	2\.XPath的功能非常强大，提供了非常简单的路径选择表达式	10](#_223)

[11\.2\.3\.	3\.以2个斜杠\(//\)开头的XPath规则会选取所有符合要求的节点	10](#_224)

[11\.2\.4\.	4\.在选取子节点时，通常会将'//'和'/'规则放在一起使用，只有一个斜杠（/）表示选取当前节点下的直接子节点	10](#_225)

[11\.2\.5\.	5\.知道子节点，想得到父节点可以使用'\.\.'，还可以使用'parent::\*'	10](#_226)

[11\.2\.6\.	6\.引用属性值需要在属性名前面加@	10](#_227)

[11\.2\.7\.	7\.在很多情况下，需要同时通过多个属性过滤节点，就需要用到XPath中的and和or关键字	11](#_228)

[11\.2\.8\.	8\.XPath提供了很多节点轴选择方法，包括获取祖先节点、兄弟节点、子孙节点等	11](#_229)

[11\.2\.9\.	9\.Chrome中Elements选项卡定位到选择对应的HTML代码，右击可以选择执行Copy\-Copy XPath命令得到对应的XPath路径	11](#_230)

[11\.2\.10\.	10\.复制XPath代码，在Console选项卡中输入"$x\('//\*\[@id="nav"\]'\)"可以用来运行XPath函数	11](#_231)

[11\.3\.	5、小结	11](#_188)

[12\.	第9章 Beautiful Soup库	11](#_112)

[12\.1\.	由于Beautiful Soup提供了多种选择器，使用起来不仅比XPath方便，而且更灵活	11](#_232)

[12\.2\.	1、Beautiful Soup库	11](#_189)

[12\.2\.1\.	1\.Beautiful Soup是一个强大的基于Python语言的XML和HTML解析库	11](#_233)

[12\.2\.2\.	2\.Beautiful Soup提供了一些简单的函数来处理导航、搜索、修改分析树等功能	11](#_234)

[12\.3\.	2、Beautiful Soup基础	11](#_190)

[12\.3\.1\.	1\.由于Beautiful Soup底层需要依赖于解析器，所以在使用时需要为其指定解析器	11](#_235)

[12\.4\.	3、节点选择器	11](#_191)

[12\.4\.1\.	1\.获取节点的名称，使用name属性	11](#_236)

[12\.4\.2\.	2\.获取节点的属性，使用attrs	12](#_237)

[12\.4\.3\.	3\.获取节点的内容，使用string属性	12](#_238)

[12\.4\.4\.	4\.获取直接子节点，使用contents属性或children属性	12](#_239)

[12\.4\.5\.	5\.获取所有子孙节点，使用descendants属性	12](#_240)

[12\.4\.6\.	6\.选择父节点，使用parent属性，所有父节点使用parents属性	12](#_241)

[12\.4\.7\.	7\.选择兄弟节点，使用next\_sibling属性	12](#_242)

[12\.5\.	4、方法选择器	12](#_192)

[12\.5\.1\.	1\.find\_all方法用于根据节点名、属性、文本内容等选择所有符合要求的节点，常用的参数包括name、attrs、text等	12](#_243)

[12\.5\.2\.	2\.find方法与find\_all方法的几点不同：find方法查询满足条件的第一个节点；find方法返回的是bs4\.element\.Tag对象	12](#_244)

[12\.6\.	5、CSS选择器	12](#_193)

[12\.6\.1\.	1\.使用CSS选择器需要使用Tag对象的select方法。常用的CSS选择器有：\.classname、nodename、\#idname	12](#_245)

[12\.7\.	8、小结	12](#_194)

[12\.7\.1\.	Beautiful Soup简直太方便了，而且还有多种选择器可以使用	12](#_246)

[13\.	第10章 pyquery库	12](#_113)

[13\.1\.	虽然Beautiful Soup库的功能非常强大，但CSS选择器功能有些弱	12](#_247)

[13\.2\.	1、pyquery简介	12](#_195)

[13\.2\.1\.	1\.喜欢用CSS选择器，而且对jQuery有所了解，那么使用pyquery正好适合	12](#_248)

[13\.3\.	2、pyquery基础	13](#_196)

[13\.3\.1\.	1\.可以通过如下3种方式将HTML文档传入PyQuery对象：字符串、URL、文件	13](#_249)

[13\.4\.	3、CSS选择器	13](#_197)

[13\.4\.1\.	1\.pyquery的CSS选择器用于指定CSS代码，并通过CSS代码选取HTML文档中对应的节点	13](#_250)

[13\.5\.	4、查找节点	13](#_198)

[13\.5\.1\.	1\.查找子节点需要使用find方法	13](#_251)

[13\.5\.2\.	2\.通过parent方法可以查找直接父节点	13](#_252)

[13\.5\.3\.	3\.使用siblings方法可以查询当前节点的所有兄弟节点	13](#_253)

[13\.5\.4\.	4\.节点包括如下信息：节点名称、节点属性、节点文本、整个节点的HTML代码、节点内部的HTML代码	13](#_254)

[13\.6\.	5、修改节点	13](#_199)

[13\.6\.1\.	1\.添加和移除节点的样式：addClass和removeClass	13](#_255)

[13\.6\.2\.	2\.修改节点属性和文本内容：attr、removeAttr、text和html	13](#_256)

[13\.6\.3\.	3\.删除节点：remove	13](#_257)

[13\.7\.	6、伪类选择器	13](#_200)

[13\.7\.1\.	1\.CSS选择器之所以强大，一个很重要的原因就是它支持多种多样的伪类选择器	13](#_258)

[13\.8\.	9、小结	13](#_201)

[13\.8\.1\.	1\.lxml的功能比较简单，只支持XPath，但运行速度比较快	13](#_259)

[13\.8\.2\.	2\.Beautiful Soup的功能丰富，支持多种选择器（节点选择器、方法选择器和CSS选择器），不过不如pyquery丰富	14](#_260)

[13\.8\.3\.	3\.pyquery虽然CSS选择器功能强大，但只支持CSS选择器，如果需要使用XPath选取节点，仍需要使用lxml或Beautiful Soup	14](#_261)

[14\.	第4篇 数据存储	14](#_114)

[15\.	第11章 文件存储	14](#_115)

[15\.1\.	保存数据有多种方式，其中最简单、成本最低的就是将数据保存在二进制或文本文件中	14](#_273)

[15\.2\.	1、打开文件	14](#_262)

[15\.2\.1\.	open函数用于打开文件，第1个参数指定文件名，第2个参数指定文件模式	14](#_274)

[15\.3\.	2、操作文件的基本方法	14](#_263)

[15\.3\.1\.	1\.使用open函数打开文件后，会返回一个TextIOWrapper对象	14](#_275)

[15\.3\.2\.	2\.对文件完成相关操作后关闭文件也没什么坏处，而且还可以避免浪费操作系统中打开文件的配额	14](#_276)

[15\.3\.3\.	3\.要读写一行或多行文本，建议使用readline方法、readlines方法和writelines方法	14](#_277)

[15\.4\.	3、使用FileInput对象读取文件	14](#_264)

[15\.4\.1\.	1\.使用readlines函数会占用太多内存	14](#_278)

[15\.4\.2\.	2\.FileInput对象使用的缓存机制，并不会一次性读取文件的所有内容	14](#_279)

[15\.5\.	4、处理XML格式的数据	14](#_265)

[15\.5\.1\.	1\.在Python语言中需要导入xml模块或其子模块，并利用其中提供的API来操作XML文件	15](#_280)

[15\.5\.2\.	2\.生成XML文件的方式有很多，可以按字符串方式生成XML文件，也可以按其他方式生成文件	15](#_281)

[15\.5\.3\.	3\.将XML字符串转换为字典，需要导入xmltodict模块	15](#_282)

[15\.6\.	5、处理JSON格式的数据	15](#_266)

[15\.6\.1\.	1\.JSON格式要比XML格式更简约	15](#_283)

[15\.6\.2\.	2\.将JSON字符串转换为字典可以使用下面两种方法：使用json模块的loads函数；使用eval函数将JSON字符串当作普通的Python代码执行	15](#_284)

[15\.6\.3\.	3\.通过loads函数的object\_hook关键字参数指定一个类或一个回调函数，可以将JSON字符串转换为类实例	15](#_285)

[15\.6\.4\.	4\.dumps函数不仅可以将字典转换为JSON字符串，还可以将类实例转换位JSON字符串	15](#_286)

[15\.7\.	6、将JSON字符串转换为XML字符串	15](#_267)

[15\.7\.1\.	1\.将JSON字符串转换为XML字符串其实只需要做一下中转即可，也就是先将JSON字符串转换为字典，然后再使用dicttoxml模块中的dicttoxml函数将字典转换为XML字符串	15](#_287)

[15\.8\.	7、CSV文件存储	15](#_268)

[15\.8\.1\.	1\.CSV文件以纯文本形式存储表格数据	15](#_288)

[15\.9\.	数据存储不仅仅只有文本文件，还有各种各样的数据库，如SQLite、MySQL、Mongodb等	15](#_289)

[16\.	第12章 数据库存储	15](#_116)

[16\.1\.	1、SQLite数据库	15](#_269)

[16\.1\.1\.	1\.SQLite是一个开源、小巧、零配置的关系型数据库，支持多种平台，包括Windows、Mac OS X、Linux、Android、IOS等	16](#_290)

[16\.1\.2\.	2\.sqlite3模块式Python语言内置的，不需要安装，直接导入就可以	16](#_291)

[16\.2\.	2、MySQL数据库	16](#_270)

[16\.2\.1\.	1\.MySQL是一个功能强大的网络关系型数据库，支持通过网络多人同时连接和操作数据库	16](#_292)

[16\.2\.2\.	2\.在Python语言中需要使用pymysql模块来操作MySQL数据库	16](#_293)

[16\.2\.3\.	3\.记住几个函数和方法：connect、cursor、execute、commit、rollback	16](#_294)

[16\.3\.	3、非关系型数据库	16](#_271)

[16\.3\.1\.	1\.非关系型数据库主要包括对象数据库、键值数据库、文档数据库、图形数据库、表格数据库等	16](#_295)

[16\.3\.2\.	2\.MongoDB是非常有名的文档数据库，所有的数据以文档形式存储	16](#_296)

[16\.3\.3\.	3\.在Python语言中使用MongoDB数据库需要先导入pymongo模块	16](#_297)

[16\.4\.	6、小结	16](#_272)

[16\.4\.1\.	1\.如果抓取的数据量比较大，而且需要后期整理和查询，建议保存到数据库中	16](#_298)

[16\.4\.2\.	2\.抓取的数据只用于用户自己分析和实验，可以保存到SQLite数据库中	16](#_299)

[16\.4\.3\.	3\.抓取的数据需要让多人访问和分析，可以考虑MySQL数据库	16](#_300)

[16\.4\.4\.	4\.抓取的数据很难整理成二位表的形式，可以考虑MongoDB这样的文档数据库	17](#_301)

[17\.	第5篇 爬虫高级应用	17](#_117)

[18\.	第13章 抓取异步数据	17](#_118)

[18\.1\.	1、异步加载与AJAX	17](#_329)

[18\.1\.1\.	其实AJAX有两层含义，一层含义是异步，指请求和下载数据的方式是异步的；另一层含义是指传输数据的格式，目前经常使用的数据格式是JSON	17](#_352)

[18\.2\.	2、基本原理	17](#_330)

[18\.2\.1\.	AJAX的实现分为3步：发送请求（通常是指HTTP请求）、解析响应（通常是指JSON格式的数据）和渲染页面（通常是指将JSON格式的数据显示在Web页面的某些元素上）	17](#_353)

[18\.3\.	3、逆向工程	17](#_331)

[18\.3\.1\.	和破解一个可执行程序一样，需要用二进制编辑工具一点一点跟踪	17](#_354)

[18\.3\.2\.	要注意的是，XHR过滤的URL与返回数据的格式无关，只与发送请求的方式有关	17](#_355)

[18\.4\.	4、提取结果	17](#_332)

[18\.5\.	5、项目实战：支持搜索功能的图片爬取	17](#_333)

[18\.6\.	6、项目实战：抓取京东图书评价	17](#_334)

[19\.	第14章 可见即可爬：Selenium	17](#_119)

[19\.1\.	数据通过AJAX方式获取，由于很多参数都是加密的，很难找到什么规律，要想抓到数据，就需要模拟浏览器来加载页面	18](#_356)

[19\.2\.	Python语言支持很多第三方模拟浏览器的程序库，如Selenium、Splash、PyV8、Ghost等	18](#_357)

[19\.3\.	1、安装Selenium	18](#_335)

[19\.3\.1\.	Selenium本质上是一款自动化测试工具，主要用于测试Web应用	18](#_358)

[19\.4\.	2、安装WebDriver	18](#_336)

[19\.4\.1\.	WebDriver是一个W3C规范，用于定义控制浏览器的API	18](#_359)

[19\.4\.2\.	ChromeDriver分为Windows、Linux和Mac版本	18](#_360)

[19\.5\.	3、Selenium的基本使用方法	18](#_337)

[19\.5\.1\.	主要功能有以下几类：打开浏览器；获取浏览器页面的特定内容；控制浏览器页面上的控件；关闭浏览器；	18](#_361)

[19\.5\.2\.	WebDriver可以模拟浏览器的一类重要操作，就是模拟按键	18](#_362)

[19\.6\.	4、查找节点	18](#_338)

[19\.6\.1\.	以find\_element开头的方法都是用于查找单个节点的API	18](#_363)

[19\.6\.2\.	以find\_elements开头的方法是可以查找多个节点的API	18](#_364)

[19\.7\.	5、节点交互	18](#_339)

[19\.7\.1\.	就是模拟浏览器的动作	18](#_365)

[19\.8\.	6、动作链	18](#_340)

[19\.8\.1\.	有一类交互动作，没有特定的执行对象，如鼠标拖拽	18](#_366)

[19\.8\.2\.	动作链需要创建ActionChains对象，并通过ActionChains类的若干方法向浏览器发送一个或多个动作	19](#_367)

[19\.9\.	7、执行JavaScript代码	19](#_341)

[19\.9\.1\.	使用execute\_script方法直接运行JavaScript代码，以便扩展selenium的功能	19](#_368)

[19\.10\.	8、获取节点信息	19](#_342)

[19\.10\.1\.	使用selenium的API还可以获得详细的节点信息，如节点的位置，节点名称，节点尺寸，节点属性值等	19](#_369)

[19\.10\.2\.	ul\.text、ul\.id、ul\.location	19](#_371)

[19\.11\.	9、管理Cookies	19](#_343)

[19\.11\.1\.	可以方便的管理Cookie，例如获取Cookie、添加和删除Cookie等	19](#_370)

[19\.11\.2\.	browser\.get\_cookies\(\)、borwser\.add\_cookie\(\)	19](#_372)

[19\.12\.	10、改变节点的属性值	19](#_344)

[19\.12\.1\.	可以通过执行JavaScript代码的方式设置节点属性，而且通过selenium获取的节点可以直接作为DOM使用	19](#_373)

[19\.13\.	11、项目实战：抓取QQ空间说说的内容	19](#_345)

[20\.	第15章 基于Splash的爬虫	19](#_120)

[20\.1\.	Splash是一个JavaScript渲染服务，是一个带有HTTP API的轻量级浏览器。可以使用Lua语言编写代码对页面进行渲染，Python可以通过HTTP API调用Splash内部的功能，甚至可以与Lua代码进行交互	19](#_374)

[20\.2\.	1、Splash基础	19](#_346)

[20\.2\.1\.	功能简介：异步处理多个网页的渲染；获取渲染后的页面源代码或截图；使用Adblock规则来加快页面渲染速度；使用JavaScript处理网页内容；通过Lua脚本来控制页面渲染过程；获取渲染的详细过程并通过HAR格式呈现	20](#_375)

[20\.3\.	2、Splash Lua脚本	20](#_347)

[20\.3\.1\.	Splash可以通过Lua脚本执行一系列渲染操作	20](#_376)

[20\.3\.2\.	基本操作：访问页面splash:go\("xxx"\)；加载等待splash:wait\(0\.5\)；执行JavaScript（splash:evaljs\("document\.title"\)）	20](#_377)

[20\.3\.3\.	Splash支持异步处理，go方法就是通过异步方式访问页面的	20](#_378)

[20\.3\.4\.	Splash对象属性：args获取加载配置参数、js\_enabled控制是否可以执行JavaScript代码、resource\_timeout设置加载时间、images\_enabled设置图片是否可以加载、plugins\_enabled控制浏览器插件是否开启、scroll\_position控制页面上下或左右滚动、go请求某个链接、wait控制页面的等待时间、jsfunc直接调用JavaScript定义的函数、autoload设置每个页面访问时自动加载的JavaScript代码、call\_later设置任务的延长时间实现任务延时执行、http\_get模拟发送HTTP GET请求、set\_content设置页面的内容、html方法获取网页源码、png方法获取png格式的页面截图、har方法导出加载网页时的详细性能数据、get\_cookies\(\)获取当前页面的cookies、get\_viewport\_size方法可以获取浏览器页面的尺寸、set\_user\_agent方法设置浏览器的User\-Agent	20](#_379)

[20\.4\.	3、使用CSS选择器	20](#_348)

[20\.4\.1\.	select方法用于查找第1个符合条件的节点	20](#_380)

[20\.4\.2\.	select\_all用于查找所有符合条件的节点	20](#_381)

[20\.5\.	4、模拟鼠标和键盘的动作	20](#_349)

[20\.5\.1\.	mouse\_click方法可以模拟鼠标单击的动作	20](#_382)

[20\.5\.2\.	send\_keys可以模拟键盘按键的动作	21](#_383)

[20\.6\.	5、Splash HTTP API	21](#_350)

[20\.6\.1\.	Splash提供的一组URL，通过为这些URL指定各种参数，可以完成对页面的各种渲染工作	21](#_384)

[20\.6\.2\.	常用API：render\.html获取JavaScript渲染的页面的HTML代码、render\.png获取网页截图、render\.har获取页面加载的HAR数据、execute可以实现Python与Lua对接	21](#_385)

[20\.7\.	6、项目实战：使用Splash Lua抓取京东搜索结果	21](#_351)

[21\.	第16章 抓取移动App的数据	21](#_121)

[21\.1\.	移动App通常都会采用异步的方式从服务端获取数据	21](#_457)

[21\.2\.	要想监控移动App发送的请求，就需要使用抓包工具，例如Charles、WireShark、Fiddler、mitmproxy等	21](#_458)

[21\.3\.	抓包工具的基本原理是在PC上可以作为代理运行，然后在手机上设置代理服务器和端口号	21](#_459)

[21\.4\.	1、使用Charles	21](#_449)

[21\.4\.1\.	Charles是一个跨平台网络抓包工具，支持Windows、Mac和Linux平台	21](#_460)

[21\.4\.2\.	首先启动Charles，然后单击Proxy\->Proxy Settings命令。在手机端需要在访问网络时先连接代理服务器，也就是Charles应用	21](#_461)

[21\.4\.3\.	要想通过Charles监听HTTPS数据，必须在PC端和手机端安装证书	21](#_462)

[21\.4\.4\.	Charles有一个重要特性是可以重复发送请求	21](#_463)

[21\.5\.	2、使用mitmproxy	21](#_451)

[21\.5\.1\.	mitmproxy是一个支持HTTP和HTTPS的抓包程序，功能与Charles类似，只不过mitmproxy是一个控制台程序，操作都需要在控制台完成	22](#_464)

[21\.5\.2\.	mitmproxy有两个关联组件：mitmdump和mitmweb	22](#_465)

[21\.5\.3\.	mitmproxy的主要功能如下：拦截HTTP和HTTPS请求和响应；保存HTTP回源，并进行分析；模拟客户端发起请求，模拟服务器返回响应；利用反向代理将浏览转发给指定的服务器；支持Mac和Linux上透明代理；利用Python对HTTP请求和响应进行实时代理	22](#_466)

[21\.5\.4\.	mitmproxy可以通过命令行对截获的信息进行编辑，可以利用这个功能重新编辑请求	22](#_467)

[21\.5\.5\.	mitmdump是mitmproxy的命令行接口，同时还可以对接Python对请求进行处理，这要比使用Charles方便不少	22](#_468)

[21\.5\.6\.	mitmproxy有3种监听请求与响应的方式：mitmproxy控制台方式；mitmdump与Python对接的方式；mitmweb可视化方式；	22](#_469)

[21\.5\.7\.	通常会使用mitmweb分析请求和响应数据，而使用mitmdump与Python结合的方式抓取并处理数据	22](#_470)

[21\.6\.	3、项目实战：实时抓取“得到”App在线课程	22](#_452)

[22\.	第17章 使用Appium在移动端抓取数据	22](#_122)

[22\.1\.	1、安装Appium	22](#_450)

[22\.1\.1\.	Appium桌面端支持全平台安装，而且提供源代码	22](#_471)

[22\.1\.2\.	AppImage是一种通用的Linux安装程序，在传统的Linux安装程序中，不同发行版本会使用不同类型的安装程序	22](#_472)

[22\.2\.	2、Appium的基本使用方法	22](#_453)

[22\.2\.1\.	获取App的appPackage至少有2种方式：利用手机本身的功能；从AndroidManifest\.xml文件中获得Package	23](#_473)

[22\.3\.	3、使用Python控制手机	23](#_454)

[22\.4\.	4、AppiumPythonClient Api	23](#_455)

[22\.4\.1\.	可以使用Selenium中差值方法来实现对App中UI元素的查找，推荐使用ID查找	23](#_474)

[22\.4\.2\.	单击元素可以使用tap方法，该方法可以模拟手指点击动作，支持多指触摸	23](#_475)

[22\.4\.3\.	可以使用scroll方法模拟屏幕滚动	23](#_476)

[22\.4\.4\.	可以使用swipe方法模拟从A点滑动到B点	23](#_477)

[22\.4\.5\.	使用drag\_and\_drop方法可以将某一个元素拖拽到另一个目标元素上	23](#_478)

[22\.4\.6\.	使用set\_text方法和send\_keys方法都可以实现文本输入	23](#_479)

[22\.4\.7\.	与Senium中的ActionChains类似，Appium中的TouchAction可支持的方法包括tap、press、long\_press、release、move\_to、cancel、wait等	23](#_480)

[22\.5\.	5、项目实战：利用Appium抓取微信朋友圈信息	23](#_456)

[23\.	第18章 多线程和多进程爬虫	23](#_123)

[23\.1\.	1、线程与进程	23](#_302)

[23\.1\.1\.	只有可执行程序被调入内存中才叫进程	23](#_310)

[23\.1\.2\.	每个进程都拥有自己的地址空间、内存、数据栈以及其他用于跟踪执行的辅助数据	23](#_311)

[23\.1\.3\.	进程可以派生（fork或spawn）新的进程来执行其他任务，不过由于每个新进程也都拥有自己的内存和数据栈等	24](#_312)

[23\.1\.4\.	线程是在同一个进程下执行的，并共享同一个上下文	24](#_313)

[23\.1\.5\.	线程属于进程，而且线程必须依赖进程才能执行。一个进程可以包含一个或多个线程	24](#_314)

[23\.1\.6\.	线程包括开始、执行和结束三部分	24](#_315)

[23\.1\.7\.	一个进程中的各个线程与主进程共享同一块数据空间	24](#_316)

[23\.1\.8\.	要注意的是，线程的执行时间是不平均的	24](#_317)

[23\.2\.	2、Python与线程	24](#_303)

[23\.2\.1\.	Python多线程在底层使用了兼容POSIX的线程，也就是众所周知的pthread	24](#_318)

[23\.2\.2\.	要注意的是，在Python2\.x中这个模块叫thread，从Python3\.x开始，thread更名为\_thread	24](#_319)

[23\.2\.3\.	锁并不是将程序锁住不退出，而是通过锁可以让程序了解是否还有线程函数没执行完，而且可以做到当所有的线程函数执行完后，程序会立刻退出，而无须任何等待	24](#_320)

[23\.3\.	3、高级线程模块	24](#_304)

[23\.3\.1\.	在threading模块中有一个非常重要的Thread类，该类的实例表示一个执行线程的对象	24](#_321)

[23\.3\.2\.	\_thread模块可以看作线程的面向过程版本，而Thread类可以看作线程的面向对象版本	24](#_322)

[23\.3\.3\.	Thread类构造方法的target关键字参数不仅可以是一个函数，还可以是一个对象，可以称这个对象为线程对象	24](#_323)

[23\.3\.4\.	从Thread类继承最简单的方式是在子类的构造方法中通过super\(\)函数调用父类的构造方法，并传入相应的参数值	25](#_324)

[23\.4\.	4、线程同步	25](#_305)

[23\.4\.1\.	线程锁的目的是将一段代码锁住，一旦获得了锁权限，除非释放线程锁，否则其他任何代码都无法再次获得锁权限	25](#_325)

[23\.4\.2\.	信号量是最古老的同步原语之一，它是一个计数器，用于记录资源消耗情况	25](#_326)

[23\.4\.3\.	要注意的是信号量对象的acquire方法与release方法	25](#_327)

[23\.5\.	5、生产者\-\-消费者问题与queue模块	25](#_306)

[23\.6\.	6、多进程	25](#_307)

[23\.6\.1\.	可以使用multiprocessing模块的进程池（Pool类），通过Pool类构造方法的processes参数，然后指定创建的进程数	25](#_328)

[23\.7\.	7、项目实战：抓取豆瓣音乐Top250排行榜（多线程版）	25](#_308)

[23\.8\.	8、项目实战：抓取豆瓣音乐Top250排行榜（多进程版）	25](#_309)

[24\.	第19章 网络爬虫框架：Scrapy	25](#_124)

[24\.1\.	1、Scrapy基础知识	25](#_428)

[24\.1\.1\.	通过Scrapy框架，可以非常轻松的实现强大的爬虫系统。	25](#_431)

[24\.1\.2\.	外围的工作，如抓取页面、保存数据、任务调度、分布式等，直接交给Scrapy就可以了	25](#_432)

[24\.1\.3\.	包括6个部分：Scrapy Engine（Scrapy引擎）：用来处理整个系统的数据流，触发各种事件；Scheduler（调度器）：从URL队列中取出一个URL；Downloader（下载器）：从Internet上下载Web资源；Spiders（网络爬虫）：接收下载器下载的原始数据，做进一步处理；Item Pipeline（项目管道）：接收网络爬虫传过来的数据，以便做进一步处理；中间件：整个Scrapy框架有很多中间件，如下载器中间件、网络爬虫中间件等	26](#_433)

[24\.1\.4\.	整个流程图中，整体在Scrapy Engine的调度下，首先运行的是Scheduler，Scheduler从下载队列中取一个URL，将这个URL交给Downloader，Downloader下载这个URL对应的Web资源，然后将下载的原始数据交给Spiders，Spiders会从原始数据中提取出有用的信息，最后将提取出来的数据交给Item Pipeline，可以通过Item Pipeline将数据保存到数据库、文本文件或其他存储介质上	26](#_434)

[24\.1\.5\.	Scrapy提供了一个Shell，相当于Python的REPL环境	26](#_435)

[24\.1\.6\.	Scrapy主要是使用XPath过滤HTML页面的内容	26](#_436)

[24\.2\.	2、用Scrapy编写网络爬虫	26](#_429)

[24\.2\.1\.	Scrapy框架提供了一个scrapy命令用来建立Scrapy工程	26](#_437)

[24\.2\.2\.	PyCharm不支持建立Scrapy工程	26](#_438)

[24\.2\.3\.	PyCharm扩展工具允许在PyCharm中通过单击命令执行外部命令	26](#_439)

[24\.2\.4\.	parse方法的返回值会被传给Item Pipeline，并由相应的Item Pipeline将数据保存成相应格式的文件。parse方法的返回值类型必须是scrapy\.Item或其scrapy\.Item的子类。	26](#_440)

[24\.2\.5\.	本质上，ItemLoader对象也是通过返回一个item的方式保存数据的，只不过ItemLoader对象将item和reponse进行了封装	26](#_441)

[24\.2\.6\.	转换的基本原理是将CSV格式的文件作为数据源来读取，然后在parse方法中将CSV文件中的数据通过Item转换为指定的格式，如JSON格式	27](#_442)

[24\.3\.	3、Scrapy的高级应用	27](#_430)

[24\.3\.1\.	Scrapy允许使用中间件干预数据的抓取过程，以及完成其他数据处理工作	27](#_443)

[24\.3\.2\.	Scrapy提供了很多内建的下载器中间件，例如下载超时、自动重定向、设置默认HTTP请求头等	27](#_444)

[24\.3\.3\.	爬虫中间件会在3个位置起作用：向服务器发送Request之前；在Downloader生成Response并发送Spider之前；在Spider生成Item并发送给Item管道之前	27](#_445)

[24\.3\.4\.	Item管道的主要功能如下：数据清理，主要清理HTML数据；校验抓取的数据，检查抓取的字段数据；查重并丢弃重复的内容；数据存储；	27](#_446)

[24\.3\.5\.	CrawlSpider是Scrapy提供的一个通用爬虫	27](#_447)

[24\.3\.6\.	一些内置的处理器：Identity最简单的Processor；TakeFirst返回列表的第一个非空值；Join处理器用于将列表中每个元素首尾相接合成一个字符串；Compose处理器允许将多个处理器或函数组成在一起使用；MapCompose可以迭代处理一个列表输入值；SelectJmes可以通过key获得JSON对象的value	27](#_448)

[25\.	第20章 综合爬虫项目：可视化爬虫	27](#_125)

# <a id="_____2"></a><a id="_101"></a>第1篇 基础知识

# <a id="_____4"></a><a id="_102"></a>第1章 开发环境配置

## <a id="_____6"></a><a id="_386"></a>1、安装官方的Python运行环境

### <a id="_____8"></a><a id="_397"></a>目前常用的操作系统是Windows、macOS和Linux三大平台

## <a id="_____10"></a><a id="_387"></a>2、配置PATH环境变量

### <a id="_____12"></a><a id="_398"></a>为了更方便的执行python命令，建议将Python安装目录添加到PATH环境变量中

## <a id="_____14"></a><a id="_388"></a>3、安装Anaconda Python开发环境

### <a id="_____16"></a><a id="_399"></a>集成的Python运行环境，除了包含Python本身的运行环境外，还集成了很多第三方模块，如numpy、pandas、flask等

## <a id="_____18"></a><a id="_389"></a>4、安装PyCharm

### <a id="_____20"></a><a id="_400"></a>一个专门用于开发Python程序的IDE

## <a id="_____22"></a><a id="_390"></a>5、配置PyCharm

# <a id="_____24"></a><a id="_103"></a>第2章 爬虫基础

## <a id="_____26"></a><a id="_391"></a>1、HTTP基础

### <a id="_____28"></a><a id="_401"></a>URI统一资源标识符，URL是URI的子集，URN统一资源名称，P2P下载中使用的磁力链接是URN的一种实现

### <a id="_____30"></a><a id="_402"></a>在Web应用中，超文本主要是指HTML代码，在浏览器中看到的内容就是浏览器解析超文本后的输出结果

### <a id="_____32"></a><a id="_403"></a>协议指数据传输协议，也就是数据的传输格式（数据传输规范）

### <a id="_____34"></a><a id="_404"></a>HTTP超文本传输协议，理论上可以传输任何类型的数据，包括超文本数据、普通的文本数据、二进制数据（如图像、视频文件等）

### <a id="_____36"></a><a id="_405"></a>HTTPS是安全的HTTP数据通道，可认为是HTTP的安全版本，即HTTP下加入SSL层

### <a id="_____38"></a><a id="_406"></a>在Chrome页面右键菜单中单击”检查“命令打开开发者工具，然后切换到Network面板

### <a id="_____40"></a><a id="_407"></a>详细信息页面有3个部分，General、Response Headers和Request Headers，分别表示基本信息、响应头信息和请求头信息

### <a id="_____42"></a><a id="_408"></a>GET和POST请求方法主要区别：GET请求中的参数都包含在URL中，数据可以在URL中看到，而POST请求提交的数据并不会包含在URL中；GET请求提交的数据最多只有1024个字节，而POST请求对提交数据的大小没有限制

### <a id="_____44"></a><a id="_409"></a>请求头用来提供服务器使用的信息，由若干个请求字段组成，Accept告知客户端可以接收什么类型的信息、Content\-Type请求体的文档类型、Cookie存储在本地的数据、Referer标识这个请求是从哪个页面发过来的、User\-Agent表示客户端的操作系统和浏览器版本

### <a id="_____46"></a><a id="_410"></a>服务端返回给客户端数据称为响应，可分为3部分：响应状态码、响应头、响应体

### <a id="_____48"></a><a id="_411"></a>响应头包含了服务器对请求的应答信息，如Content\-Type、Date、Server等

### <a id="_____50"></a><a id="_412"></a>响应体是服务器对客户端具体的响应数据，可以包含任何格式的内容

## <a id="_____52"></a><a id="_392"></a>2、网页基础

### <a id="_____54"></a><a id="_413"></a>Web三剑客：HTML、CSS和JavaScript

### <a id="_____56"></a><a id="_414"></a>HTML用来描述网页的一种语言，用不同的标记表示各种节点

### <a id="_____58"></a><a id="_415"></a>CSS的主要作用是：将由HTML定义的页面节点安排到合适的位置即布局了；设置页面节点的样式；

### <a id="_____60"></a><a id="_416"></a>CSS的核心是选择器，选择器的作用就是让CSS知道需要设置哪些HTML节点

### <a id="_____62"></a><a id="_417"></a>实现页面特效，或从服务端使用AJAX获取数据并动态显示在Web页面中就需要借助JavaScript

## <a id="_____64"></a><a id="_393"></a>3、爬虫的基本原理

### <a id="_____66"></a><a id="_418"></a>爬虫，主要的功能是下载Internet或局域网中的各种资源

### <a id="_____68"></a><a id="_419"></a>分类：全网爬虫、站内爬虫、定向爬虫

### <a id="_____70"></a><a id="_420"></a>在Python语言中有很多库可以实现从网络上下载资源的功能，如urllib、request等

## <a id="_____72"></a><a id="_394"></a>4、Session与Cookie

### <a id="_____74"></a><a id="_421"></a>静态页面的内容是使用HTML代码编写的，文件中的任何内容都是固定的，除非直接修改文件

### <a id="_____76"></a><a id="_422"></a>动态页面的实现方式非常多，都是由服务端根据不同的条件动态向客户端发送内容

### <a id="_____78"></a><a id="_423"></a>模拟登录的方式很多，其中最常用的方式就是Cookie劫持

### <a id="_____80"></a><a id="_424"></a>HTTP的无状态是指HTTP协议在客户端与服务端交互的过程中不保留状态

### <a id="_____82"></a><a id="_425"></a>Session与Cookies类似，只是将数据保存 服务端

### <a id="_____84"></a><a id="_426"></a>查看Cookie的方式，最简单的就是通过Chrome浏览器开发者工具的Application选项卡

## <a id="_____86"></a><a id="_395"></a>5、实战案例：抓取所有的网络资源

### <a id="_____88"></a><a id="_427"></a>全网爬虫至少有一个入口点，然后爬虫抓取这个入口点指向的页面，接下来将该页面中所有链接节点中href属性的提取出来

## <a id="_____90"></a><a id="_396"></a>6、实战案例：抓取博客文章列表

# <a id="_____92"></a><a id="_104"></a>第2篇 网络库

# <a id="_____94"></a><a id="_105"></a>第3章 网络库urllib

## <a id="_____96"></a><a id="_126"></a>1、urllib简介

### <a id="_____98"></a><a id="_147"></a>urllib包含4个模块：request基本HTTP请求模块；error异常处理模块；parse工具模块；robotparser识别网站robots文件

## <a id="_____100"></a><a id="_127"></a>2、发送请求与获得响应

### <a id="_____102"></a><a id="_148"></a>1\.发送HTTP请求通过urlopen函数就可以搞定

### <a id="_____104"></a><a id="_149"></a>2\.urlopen函数返回的是HTTPResponse类型的对象，主要包含read、getheader、getheaders等方法，以及msg、version、status、debuglevel、closed等属性

### <a id="_____106"></a><a id="_150"></a>3\.发送HTTP POST请求需要使用data命令参数，该参数是bytes类型

### <a id="_____108"></a><a id="_151"></a>4\.请求超时通过urlopen函数的timeout命名参数进行设置，单位为秒

### <a id="_____110"></a><a id="_152"></a>5\.要想色值HTTP请求头，需要为urlopen函数传入Request对象，可以通过Request类构造方法的headers命名参数设置HTTP请求头

### <a id="_____112"></a><a id="_153"></a>6\.有时需要将HTTP请求头的值设为中文，但直接设成中文，会抛出异常。为了解决这个问题，在设置HTTP请求头时需要将中文编码，发送到服务端后，在服务端用同样的规则解码

### <a id="_____114"></a><a id="_154"></a>7\.用户名和密码是通过HTTP请求头的Authrization字段发送给服务端的，所以在访问该页面时可以直接设置Authorization字段

### <a id="_____116"></a><a id="_155"></a>8\.使用ProxyHandler类可以设置HTTP和HTTPS代理

### <a id="_____118"></a><a id="_156"></a>9\.读取Cookie需要创建http\.cookiejar\.CookieJar类的实例传入urllib\.request\.HTTPCookieProcessor类的实例，并将http\.cookiejar\.CookieJar类的实例传入urllib\.request\.HTTPCookieProcessor类的构造方法中

## <a id="_____120"></a><a id="_128"></a>3、异常处理

### <a id="_____122"></a><a id="_157"></a>1\.异常类都在urllib的error模块中定义，主要有两个异常类：URLError和HTTPError

### <a id="_____124"></a><a id="_158"></a>2\.URLError类属于urllib库的error模块，该类从OSError类继承，是error模块中的异常基类，由request模块产生的异常都可以通过URLError来捕获

### <a id="_____126"></a><a id="_159"></a>3\.HTTPError是URLError的子类，专门用于处理HTTP请求错误，比如400、404错误

## <a id="_____128"></a><a id="_129"></a>4、解析链接

### <a id="_____130"></a><a id="_160"></a>1\.urllib库里的parse模块可以用来解析URL

### <a id="_____132"></a><a id="_161"></a>2\.parse模块支持如下协议的URL处理：file、ftp、gopher、hdl、http、https、imap、mailto、mms、news、nntp、prospero、rsync、rtsp、rtspu、sftp、shttp、sip、sips、snews、svn、svn\+ssh、wais、ws、wss

### <a id="_____134"></a><a id="_162"></a>3\.拆分与合并URL（urlparse、urlunparse）；另一种拆分与合并的方式（urlsplit、urlunsplit）；连接URL（urljoin）；URL编码（urlencode）；编码与解码（quote与unquote）；参数转换（parse\_qs与parse\_qsl）

## <a id="_____136"></a><a id="_130"></a>5、Robots协议

### <a id="_____138"></a><a id="_163"></a>1\.Robots协议也称作爬虫协议、机器人协议，它的全名是网络爬虫排除标准，用来告诉爬虫和搜索引擎哪些页面可以抓取，哪些不可以抓取

### <a id="_____140"></a><a id="_164"></a>2\.robots\.txt文件中有2个重要的授权指令：Disallow和Allow，前者表示禁止抓取，后者表示允许抓取

### <a id="_____142"></a><a id="_165"></a>3\.RobotFileParser类的构造方法也可以接收一个URL，然后使用can\_fetch方法判断是否可以抓取某一个页面

# <a id="_____144"></a><a id="_106"></a>第4章 网络库urllib3

## <a id="_____146"></a><a id="_131"></a>1、urllib3简介

### <a id="_____148"></a><a id="_166"></a>1\.urllib主要侧重于URL的请求构造，而urllib2侧重于HTTP请求的处理，而urllib3则是服务于升级的HTTP1\.1标准，且拥有高效HTTP连接池管理及HTTP代理服务的功能库

## <a id="_____150"></a><a id="_132"></a>2、urllib3模块

### <a id="_____152"></a><a id="_167"></a>1\.urllib3提供了很多python标准库里所没有的重要特性，这些特性包括：线程安全；连接池；客户端SSL/TLS验证；使用multipart编码上传文件；协助处理重复请求和HTTP重定位；支持压缩编码；支持HTTP和Socks代理；100%测试覆盖率；

## <a id="_____154"></a><a id="_133"></a>3、发送HTTP GET请求

## <a id="_____156"></a><a id="_134"></a>4、发送HTTP POST请求

## <a id="_____158"></a><a id="_135"></a>5、HTTP请求头

### <a id="_____160"></a><a id="_168"></a>1\.通过PoolManager对象的request方法的headers关键字参数可以指定字典形式的HTTP请求头

## <a id="_____162"></a><a id="_136"></a>6、HTTP响应头

## <a id="_____164"></a><a id="_137"></a>7、上传文件

## <a id="_____166"></a><a id="_138"></a>8、超时

### <a id="_____168"></a><a id="_169"></a>1\.由于HTTP底层是基于Socket实现的，所以连接的过程中也可能超时。Socket超时分为连接超时和读超时

# <a id="_____170"></a><a id="_107"></a>第5章 网络库requests

## <a id="_____172"></a><a id="_175"></a>requests是功能强大且使用方便的Python网络库

## <a id="_____174"></a><a id="_139"></a>1、基本用法

### <a id="_____176"></a><a id="_170"></a>1\.get方法指定的URL不仅可以是网页，还可以是任何二进制文件，如png图像、pdf文档等

## <a id="_____178"></a><a id="_140"></a>2、高级用法

### <a id="_____180"></a><a id="_171"></a>1\.使用requests上传文件是相当简单的，只需指定post方法的files参数即可

### <a id="_____182"></a><a id="_172"></a>2\.requests使用代理非常容易，只需指定proxies参数即可

### <a id="_____184"></a><a id="_173"></a>3\.为了避免抛出异常而导致的程序崩溃，通常的做法是使用try\.\.\.except语句来捕捉超时异常

## <a id="_____186"></a><a id="_141"></a>3、小结

### <a id="_____188"></a><a id="_174"></a>1\.requests使用起来真是太方便了，很多案例都完成了复杂的功能，但代码量却很少

# <a id="_____190"></a><a id="_108"></a>第6章 Twisted网络框架

## <a id="_____192"></a><a id="_176"></a>Twisted是一个完整的事件驱动的网络框架。爬虫框架Scrapy就是使用Twisted框架编写的

## <a id="_____194"></a><a id="_142"></a>1、异步编程模型

### <a id="_____196"></a><a id="_177"></a>1\.目前常用的编程模型有3种：同步编程模型、线程编程模型和异步编程模型

### <a id="_____198"></a><a id="_178"></a>2\.如果要完成多个任务，比较有效的方式是将这些任务分解，然后启动多个线程，每个线程处理一部分任务，最后再将处理结果合并

### <a id="_____200"></a><a id="_179"></a>3\.采用异步编程模型，当一个任务被阻塞后，就会立刻执行另一个任务

## <a id="_____202"></a><a id="_143"></a>2、Reactor（反应堆）模式

### <a id="_____204"></a><a id="_180"></a>1\.这种利用循环体来等待事件发生，然后处理发生的事件的模型被设计成了一个模式：Reactor（反应堆）模式

## <a id="_____206"></a><a id="_144"></a>3、HelloWorld，Twisted框架

### <a id="_____208"></a><a id="_181"></a>1\.用于回调的代码是我们传递给Twisted的

## <a id="_____210"></a><a id="_145"></a>4、用Twisted实现时间戳客户端

### <a id="_____212"></a><a id="_182"></a>1\.Twisted框架的异步机制是整个框架的基础，可以在这个基础上实现很多基于异步编程模型的应用

## <a id="_____214"></a><a id="_146"></a>5、用Twisted实现时间戳服务端

# <a id="_____216"></a><a id="_109"></a>第3篇 解析库

# <a id="_____218"></a><a id="_110"></a>第7章 正则表达式

## <a id="_____220"></a><a id="_202"></a>Python语言内置的功能主要是正则表达式，通过正则表达式，可以对任意字符串进行搜索、分组等复杂操作

## <a id="_____222"></a><a id="_183"></a>1、使用正则表达式

### <a id="_____224"></a><a id="_203"></a>1\.使用match方法匹配字符串，该方法用于指定文本模式和待匹配的字符串

### <a id="_____226"></a><a id="_204"></a>2\.使用search方法在一个字符串中查找模式，该方法用于在一段文本中找到一个或多个与文本模式相匹配的字符串

### <a id="_____228"></a><a id="_205"></a>3\.匹配多个字符串，最简单的方法是在文本模式字符串中使用择一匹配符号（|）

### <a id="_____230"></a><a id="_206"></a>4\.匹配一类字符串的特殊符号：点\(\.\)

### <a id="_____232"></a><a id="_207"></a>5\.使用字符集，某些字符可以有多个选择，就需要使用字符集（\[\]）

### <a id="_____234"></a><a id="_208"></a>6\.重复、可选和特殊字符，要对重复模式进行匹配，就需要使用两个符号："\*"和"\+"

### <a id="_____236"></a><a id="_209"></a>7\.分组，可以通过group方法的参数获取指定的组匹配的字符串

### <a id="_____238"></a><a id="_210"></a>8\.匹配字符串的起始和结尾以及单词边界，"^"符号用于表示匹配字符串的开始，"$"符号用于表示匹配字符串的结束

### <a id="_____240"></a><a id="_211"></a>9\.使用findall和finditer查找每一个出现的位置。findall函数用于查询字符串中某个正则表达式模式全部的非重复出现情况。与match函数和search函数不同之处在于，findall函数总是返回一个包含搜索结果的列表。finditer函数在功能上与findall函数类似，只是更节省内存

### <a id="_____242"></a><a id="_212"></a>10\.用sub和subn搜索与替换，用于实现搜索和替换功能。

### <a id="_____244"></a><a id="_213"></a>11\.使用split分隔字符串。用于根据正则表达式分隔字符串

## <a id="_____246"></a><a id="_184"></a>2、一些常用的正则表达式

### <a id="_____248"></a><a id="_214"></a>1\.Email：'\[0\-9a\-zA\-Z\]\+@\[0\-9a\-zA\-Z\]\+\\\.\[a\-zA\-Z\]\{2,3\}'

### <a id="_____250"></a><a id="_215"></a>2\.IP地址：'\\d\{1,3\}\.\\d\{1,3\}\.\\d\{1,3\}\.\\d\{1,3\}'

### <a id="_____252"></a><a id="_216"></a>3\.Web地址：'https?:/\{2\}\\w\.\+'

## <a id="_____254"></a><a id="_185"></a>6、小结

### <a id="_____256"></a><a id="_217"></a>1\.其实正则表达式并不是解决搜索和匹配问题的唯一方式，有很多现成的库提供了大量的API可以对复杂数据进行搜索和定位

# <a id="_____258"></a><a id="_111"></a>第8章 lxml与XPath

## <a id="_____260"></a><a id="_186"></a>1、lxml基础

### <a id="_____262"></a><a id="_218"></a>1\.lxml是Python的一个解析库，用于解析HTML和XML，支持XPath解析方式

### <a id="_____264"></a><a id="_219"></a>2\.lxml底层是使用C语言编写的，所以解析效率非常高

### <a id="_____266"></a><a id="_220"></a>3\.parse函数返回值是lxml\.etree\.\_ElementTree对象

### <a id="_____268"></a><a id="_221"></a>4\.使用lxml操作HTML的方式与操作XML非常类似

## <a id="_____270"></a><a id="_187"></a>2、XPath

### <a id="_____272"></a><a id="_222"></a>1\.XPath的英文全称是XML Path Language，中文是XML路径语言，是一种XML文档中查找信息的语言，最初 是用于在XML文档中搜索节点的，但同样可用于HTML文档的搜索

### <a id="_____274"></a><a id="_223"></a>2\.XPath的功能非常强大，提供了非常简单的路径选择表达式

### <a id="_____276"></a><a id="_224"></a>3\.以2个斜杠\(//\)开头的XPath规则会选取所有符合要求的节点

### <a id="_____278"></a><a id="_225"></a>4\.在选取子节点时，通常会将'//'和'/'规则放在一起使用，只有一个斜杠（/）表示选取当前节点下的直接子节点

### <a id="_____280"></a><a id="_226"></a>5\.知道子节点，想得到父节点可以使用'\.\.'，还可以使用'parent::\*'

### <a id="_____282"></a><a id="_227"></a>6\.引用属性值需要在属性名前面加@

### <a id="_____284"></a><a id="_228"></a>7\.在很多情况下，需要同时通过多个属性过滤节点，就需要用到XPath中的and和or关键字

### <a id="_____286"></a><a id="_229"></a>8\.XPath提供了很多节点轴选择方法，包括获取祖先节点、兄弟节点、子孙节点等

### <a id="_____288"></a><a id="_230"></a>9\.Chrome中Elements选项卡定位到选择对应的HTML代码，右击可以选择执行Copy\-Copy XPath命令得到对应的XPath路径

### <a id="_____290"></a><a id="_231"></a>10\.复制XPath代码，在Console选项卡中输入"$x\('//\*\[@id="nav"\]'\)"可以用来运行XPath函数

## <a id="_____292"></a><a id="_188"></a>5、小结

# <a id="_____294"></a><a id="_112"></a>第9章 Beautiful Soup库

## <a id="_____296"></a><a id="_232"></a>由于Beautiful Soup提供了多种选择器，使用起来不仅比XPath方便，而且更灵活

## <a id="_____298"></a><a id="_189"></a>1、Beautiful Soup库

### <a id="_____300"></a><a id="_233"></a>1\.Beautiful Soup是一个强大的基于Python语言的XML和HTML解析库

### <a id="_____302"></a><a id="_234"></a>2\.Beautiful Soup提供了一些简单的函数来处理导航、搜索、修改分析树等功能

## <a id="_____304"></a><a id="_190"></a>2、Beautiful Soup基础

### <a id="_____306"></a><a id="_235"></a>1\.由于Beautiful Soup底层需要依赖于解析器，所以在使用时需要为其指定解析器

## <a id="_____308"></a><a id="_191"></a>3、节点选择器

### <a id="_____310"></a><a id="_236"></a>1\.获取节点的名称，使用name属性

### <a id="_____312"></a><a id="_237"></a>2\.获取节点的属性，使用attrs

### <a id="_____314"></a><a id="_238"></a>3\.获取节点的内容，使用string属性

### <a id="_____316"></a><a id="_239"></a>4\.获取直接子节点，使用contents属性或children属性

### <a id="_____318"></a><a id="_240"></a>5\.获取所有子孙节点，使用descendants属性

### <a id="_____320"></a><a id="_241"></a>6\.选择父节点，使用parent属性，所有父节点使用parents属性

### <a id="_____322"></a><a id="_242"></a>7\.选择兄弟节点，使用next\_sibling属性

## <a id="_____324"></a><a id="_192"></a>4、方法选择器

### <a id="_____326"></a><a id="_243"></a>1\.find\_all方法用于根据节点名、属性、文本内容等选择所有符合要求的节点，常用的参数包括name、attrs、text等

### <a id="_____328"></a><a id="_244"></a>2\.find方法与find\_all方法的几点不同：find方法查询满足条件的第一个节点；find方法返回的是bs4\.element\.Tag对象

## <a id="_____330"></a><a id="_193"></a>5、CSS选择器

### <a id="_____332"></a><a id="_245"></a>1\.使用CSS选择器需要使用Tag对象的select方法。常用的CSS选择器有：\.classname、nodename、\#idname

## <a id="_____334"></a><a id="_194"></a>8、小结

### <a id="_____336"></a><a id="_246"></a>Beautiful Soup简直太方便了，而且还有多种选择器可以使用

# <a id="_____338"></a><a id="_113"></a>第10章 pyquery库

## <a id="_____340"></a><a id="_247"></a>虽然Beautiful Soup库的功能非常强大，但CSS选择器功能有些弱

## <a id="_____342"></a><a id="_195"></a>1、pyquery简介

### <a id="_____344"></a><a id="_248"></a>1\.喜欢用CSS选择器，而且对jQuery有所了解，那么使用pyquery正好适合

## <a id="_____346"></a><a id="_196"></a>2、pyquery基础

### <a id="_____348"></a><a id="_249"></a>1\.可以通过如下3种方式将HTML文档传入PyQuery对象：字符串、URL、文件

## <a id="_____350"></a><a id="_197"></a>3、CSS选择器

### <a id="_____352"></a><a id="_250"></a>1\.pyquery的CSS选择器用于指定CSS代码，并通过CSS代码选取HTML文档中对应的节点

## <a id="_____354"></a><a id="_198"></a>4、查找节点

### <a id="_____356"></a><a id="_251"></a>1\.查找子节点需要使用find方法

### <a id="_____358"></a><a id="_252"></a>2\.通过parent方法可以查找直接父节点

### <a id="_____360"></a><a id="_253"></a>3\.使用siblings方法可以查询当前节点的所有兄弟节点

### <a id="_____362"></a><a id="_254"></a>4\.节点包括如下信息：节点名称、节点属性、节点文本、整个节点的HTML代码、节点内部的HTML代码

## <a id="_____364"></a><a id="_199"></a>5、修改节点

### <a id="_____366"></a><a id="_255"></a>1\.添加和移除节点的样式：addClass和removeClass

### <a id="_____368"></a><a id="_256"></a>2\.修改节点属性和文本内容：attr、removeAttr、text和html

### <a id="_____370"></a><a id="_257"></a>3\.删除节点：remove

## <a id="_____372"></a><a id="_200"></a>6、伪类选择器

### <a id="_____374"></a><a id="_258"></a>1\.CSS选择器之所以强大，一个很重要的原因就是它支持多种多样的伪类选择器

## <a id="_____376"></a><a id="_201"></a>9、小结

### <a id="_____378"></a><a id="_259"></a>1\.lxml的功能比较简单，只支持XPath，但运行速度比较快

### <a id="_____380"></a><a id="_260"></a>2\.Beautiful Soup的功能丰富，支持多种选择器（节点选择器、方法选择器和CSS选择器），不过不如pyquery丰富

### <a id="_____382"></a><a id="_261"></a>3\.pyquery虽然CSS选择器功能强大，但只支持CSS选择器，如果需要使用XPath选取节点，仍需要使用lxml或Beautiful Soup

# <a id="_____384"></a><a id="_114"></a>第4篇 数据存储

# <a id="_____386"></a><a id="_115"></a>第11章 文件存储

## <a id="_____388"></a><a id="_273"></a>保存数据有多种方式，其中最简单、成本最低的就是将数据保存在二进制或文本文件中

## <a id="_____390"></a><a id="_262"></a>1、打开文件

### <a id="_____392"></a><a id="_274"></a>open函数用于打开文件，第1个参数指定文件名，第2个参数指定文件模式

## <a id="_____394"></a><a id="_263"></a>2、操作文件的基本方法

### <a id="_____396"></a><a id="_275"></a>1\.使用open函数打开文件后，会返回一个TextIOWrapper对象

### <a id="_____398"></a><a id="_276"></a>2\.对文件完成相关操作后关闭文件也没什么坏处，而且还可以避免浪费操作系统中打开文件的配额

### <a id="_____400"></a><a id="_277"></a>3\.要读写一行或多行文本，建议使用readline方法、readlines方法和writelines方法

## <a id="_____402"></a><a id="_264"></a>3、使用FileInput对象读取文件

### <a id="_____404"></a><a id="_278"></a>1\.使用readlines函数会占用太多内存

### <a id="_____406"></a><a id="_279"></a>2\.FileInput对象使用的缓存机制，并不会一次性读取文件的所有内容

## <a id="_____408"></a><a id="_265"></a>4、处理XML格式的数据

### <a id="_____410"></a><a id="_280"></a>1\.在Python语言中需要导入xml模块或其子模块，并利用其中提供的API来操作XML文件

### <a id="_____412"></a><a id="_281"></a>2\.生成XML文件的方式有很多，可以按字符串方式生成XML文件，也可以按其他方式生成文件

### <a id="_____414"></a><a id="_282"></a>3\.将XML字符串转换为字典，需要导入xmltodict模块

## <a id="_____416"></a><a id="_266"></a>5、处理JSON格式的数据

### <a id="_____418"></a><a id="_283"></a>1\.JSON格式要比XML格式更简约

### <a id="_____420"></a><a id="_284"></a>2\.将JSON字符串转换为字典可以使用下面两种方法：使用json模块的loads函数；使用eval函数将JSON字符串当作普通的Python代码执行

### <a id="_____422"></a><a id="_285"></a>3\.通过loads函数的object\_hook关键字参数指定一个类或一个回调函数，可以将JSON字符串转换为类实例

### <a id="_____424"></a><a id="_286"></a>4\.dumps函数不仅可以将字典转换为JSON字符串，还可以将类实例转换位JSON字符串

## <a id="_____426"></a><a id="_267"></a>6、将JSON字符串转换为XML字符串

### <a id="_____428"></a><a id="_287"></a>1\.将JSON字符串转换为XML字符串其实只需要做一下中转即可，也就是先将JSON字符串转换为字典，然后再使用dicttoxml模块中的dicttoxml函数将字典转换为XML字符串

## <a id="_____430"></a><a id="_268"></a>7、CSV文件存储

### <a id="_____432"></a><a id="_288"></a>1\.CSV文件以纯文本形式存储表格数据

## <a id="_____434"></a><a id="_289"></a>数据存储不仅仅只有文本文件，还有各种各样的数据库，如SQLite、MySQL、Mongodb等

# <a id="_____436"></a><a id="_116"></a>第12章 数据库存储

## <a id="_____438"></a><a id="_269"></a>1、SQLite数据库

### <a id="_____440"></a><a id="_290"></a>1\.SQLite是一个开源、小巧、零配置的关系型数据库，支持多种平台，包括Windows、Mac OS X、Linux、Android、IOS等

### <a id="_____442"></a><a id="_291"></a>2\.sqlite3模块式Python语言内置的，不需要安装，直接导入就可以

## <a id="_____444"></a><a id="_270"></a>2、MySQL数据库

### <a id="_____446"></a><a id="_292"></a>1\.MySQL是一个功能强大的网络关系型数据库，支持通过网络多人同时连接和操作数据库

### <a id="_____448"></a><a id="_293"></a>2\.在Python语言中需要使用pymysql模块来操作MySQL数据库

### <a id="_____450"></a><a id="_294"></a>3\.记住几个函数和方法：connect、cursor、execute、commit、rollback

## <a id="_____452"></a><a id="_271"></a>3、非关系型数据库

### <a id="_____454"></a><a id="_295"></a>1\.非关系型数据库主要包括对象数据库、键值数据库、文档数据库、图形数据库、表格数据库等

### <a id="_____456"></a><a id="_296"></a>2\.MongoDB是非常有名的文档数据库，所有的数据以文档形式存储

### <a id="_____458"></a><a id="_297"></a>3\.在Python语言中使用MongoDB数据库需要先导入pymongo模块

## <a id="_____460"></a><a id="_272"></a>6、小结

### <a id="_____462"></a><a id="_298"></a>1\.如果抓取的数据量比较大，而且需要后期整理和查询，建议保存到数据库中

### <a id="_____464"></a><a id="_299"></a>2\.抓取的数据只用于用户自己分析和实验，可以保存到SQLite数据库中

### <a id="_____466"></a><a id="_300"></a>3\.抓取的数据需要让多人访问和分析，可以考虑MySQL数据库

### <a id="_____468"></a><a id="_301"></a>4\.抓取的数据很难整理成二位表的形式，可以考虑MongoDB这样的文档数据库

# <a id="_____470"></a><a id="_117"></a>第5篇 爬虫高级应用

# <a id="_____472"></a><a id="_118"></a>第13章 抓取异步数据

## <a id="_____474"></a><a id="_329"></a>1、异步加载与AJAX

### <a id="_____476"></a><a id="_352"></a>其实AJAX有两层含义，一层含义是异步，指请求和下载数据的方式是异步的；另一层含义是指传输数据的格式，目前经常使用的数据格式是JSON

## <a id="_____478"></a><a id="_330"></a>2、基本原理

### <a id="_____480"></a><a id="_353"></a>AJAX的实现分为3步：发送请求（通常是指HTTP请求）、解析响应（通常是指JSON格式的数据）和渲染页面（通常是指将JSON格式的数据显示在Web页面的某些元素上）

## <a id="_____482"></a><a id="_331"></a>3、逆向工程

### <a id="_____484"></a><a id="_354"></a>和破解一个可执行程序一样，需要用二进制编辑工具一点一点跟踪

### <a id="_____486"></a><a id="_355"></a>要注意的是，XHR过滤的URL与返回数据的格式无关，只与发送请求的方式有关

## <a id="_____488"></a><a id="_332"></a>4、提取结果

## <a id="_____490"></a><a id="_333"></a>5、项目实战：支持搜索功能的图片爬取

## <a id="_____492"></a><a id="_334"></a>6、项目实战：抓取京东图书评价

# <a id="_____494"></a><a id="_119"></a>第14章 可见即可爬：Selenium

## <a id="_____496"></a><a id="_356"></a>数据通过AJAX方式获取，由于很多参数都是加密的，很难找到什么规律，要想抓到数据，就需要模拟浏览器来加载页面

## <a id="_____498"></a><a id="_357"></a>Python语言支持很多第三方模拟浏览器的程序库，如Selenium、Splash、PyV8、Ghost等

## <a id="_____500"></a><a id="_335"></a>1、安装Selenium

### <a id="_____502"></a><a id="_358"></a>Selenium本质上是一款自动化测试工具，主要用于测试Web应用

## <a id="_____504"></a><a id="_336"></a>2、安装WebDriver

### <a id="_____506"></a><a id="_359"></a>WebDriver是一个W3C规范，用于定义控制浏览器的API

### <a id="_____508"></a><a id="_360"></a>ChromeDriver分为Windows、Linux和Mac版本

## <a id="_____510"></a><a id="_337"></a>3、Selenium的基本使用方法

### <a id="_____512"></a><a id="_361"></a>主要功能有以下几类：打开浏览器；获取浏览器页面的特定内容；控制浏览器页面上的控件；关闭浏览器；

### <a id="_____514"></a><a id="_362"></a>WebDriver可以模拟浏览器的一类重要操作，就是模拟按键

## <a id="_____516"></a><a id="_338"></a>4、查找节点

### <a id="_____518"></a><a id="_363"></a>以find\_element开头的方法都是用于查找单个节点的API

### <a id="_____520"></a><a id="_364"></a>以find\_elements开头的方法是可以查找多个节点的API

## <a id="_____522"></a><a id="_339"></a>5、节点交互

### <a id="_____524"></a><a id="_365"></a>就是模拟浏览器的动作

## <a id="_____526"></a><a id="_340"></a>6、动作链

### <a id="_____528"></a><a id="_366"></a>有一类交互动作，没有特定的执行对象，如鼠标拖拽

### <a id="_____530"></a><a id="_367"></a>动作链需要创建ActionChains对象，并通过ActionChains类的若干方法向浏览器发送一个或多个动作

## <a id="_____532"></a><a id="_341"></a>7、执行JavaScript代码

### <a id="_____534"></a><a id="_368"></a>使用execute\_script方法直接运行JavaScript代码，以便扩展selenium的功能

## <a id="_____536"></a><a id="_342"></a>8、获取节点信息

### <a id="_____538"></a><a id="_369"></a>使用selenium的API还可以获得详细的节点信息，如节点的位置，节点名称，节点尺寸，节点属性值等

### <a id="_____540"></a><a id="_371"></a>ul\.text、ul\.id、ul\.location

## <a id="_____542"></a><a id="_343"></a>9、管理Cookies

### <a id="_____544"></a><a id="_370"></a>可以方便的管理Cookie，例如获取Cookie、添加和删除Cookie等

### <a id="_____546"></a><a id="_372"></a>browser\.get\_cookies\(\)、borwser\.add\_cookie\(\)

## <a id="_____548"></a><a id="_344"></a>10、改变节点的属性值

### <a id="_____550"></a><a id="_373"></a>可以通过执行JavaScript代码的方式设置节点属性，而且通过selenium获取的节点可以直接作为DOM使用

## <a id="_____552"></a><a id="_345"></a>11、项目实战：抓取QQ空间说说的内容

# <a id="_____554"></a><a id="_120"></a>第15章 基于Splash的爬虫

## <a id="_____556"></a><a id="_374"></a>Splash是一个JavaScript渲染服务，是一个带有HTTP API的轻量级浏览器。可以使用Lua语言编写代码对页面进行渲染，Python可以通过HTTP API调用Splash内部的功能，甚至可以与Lua代码进行交互

## <a id="_____558"></a><a id="_346"></a>1、Splash基础

### <a id="_____560"></a><a id="_375"></a>功能简介：异步处理多个网页的渲染；获取渲染后的页面源代码或截图；使用Adblock规则来加快页面渲染速度；使用JavaScript处理网页内容；通过Lua脚本来控制页面渲染过程；获取渲染的详细过程并通过HAR格式呈现

## <a id="_____562"></a><a id="_347"></a>2、Splash Lua脚本

### <a id="_____564"></a><a id="_376"></a>Splash可以通过Lua脚本执行一系列渲染操作

### <a id="_____566"></a><a id="_377"></a>基本操作：访问页面splash:go\("xxx"\)；加载等待splash:wait\(0\.5\)；执行JavaScript（splash:evaljs\("document\.title"\)）

### <a id="_____568"></a><a id="_378"></a>Splash支持异步处理，go方法就是通过异步方式访问页面的

### <a id="_____570"></a><a id="_379"></a>Splash对象属性：args获取加载配置参数、js\_enabled控制是否可以执行JavaScript代码、resource\_timeout设置加载时间、images\_enabled设置图片是否可以加载、plugins\_enabled控制浏览器插件是否开启、scroll\_position控制页面上下或左右滚动、go请求某个链接、wait控制页面的等待时间、jsfunc直接调用JavaScript定义的函数、autoload设置每个页面访问时自动加载的JavaScript代码、call\_later设置任务的延长时间实现任务延时执行、http\_get模拟发送HTTP GET请求、set\_content设置页面的内容、html方法获取网页源码、png方法获取png格式的页面截图、har方法导出加载网页时的详细性能数据、get\_cookies\(\)获取当前页面的cookies、get\_viewport\_size方法可以获取浏览器页面的尺寸、set\_user\_agent方法设置浏览器的User\-Agent

## <a id="_____572"></a><a id="_348"></a>3、使用CSS选择器

### <a id="_____574"></a><a id="_380"></a>select方法用于查找第1个符合条件的节点

### <a id="_____576"></a><a id="_381"></a>select\_all用于查找所有符合条件的节点

## <a id="_____578"></a><a id="_349"></a>4、模拟鼠标和键盘的动作

### <a id="_____580"></a><a id="_382"></a>mouse\_click方法可以模拟鼠标单击的动作

### <a id="_____582"></a><a id="_383"></a>send\_keys可以模拟键盘按键的动作

## <a id="_____584"></a><a id="_350"></a>5、Splash HTTP API

### <a id="_____586"></a><a id="_384"></a>Splash提供的一组URL，通过为这些URL指定各种参数，可以完成对页面的各种渲染工作

### <a id="_____588"></a><a id="_385"></a>常用API：render\.html获取JavaScript渲染的页面的HTML代码、render\.png获取网页截图、render\.har获取页面加载的HAR数据、execute可以实现Python与Lua对接

## <a id="_____590"></a><a id="_351"></a>6、项目实战：使用Splash Lua抓取京东搜索结果

# <a id="_____592"></a><a id="_121"></a>第16章 抓取移动App的数据

## <a id="_____594"></a><a id="_457"></a>移动App通常都会采用异步的方式从服务端获取数据

## <a id="_____596"></a><a id="_458"></a>要想监控移动App发送的请求，就需要使用抓包工具，例如Charles、WireShark、Fiddler、mitmproxy等

## <a id="_____598"></a><a id="_459"></a>抓包工具的基本原理是在PC上可以作为代理运行，然后在手机上设置代理服务器和端口号

## <a id="_____600"></a><a id="_449"></a>1、使用Charles

### <a id="_____602"></a><a id="_460"></a>Charles是一个跨平台网络抓包工具，支持Windows、Mac和Linux平台

### <a id="_____604"></a><a id="_461"></a>首先启动Charles，然后单击Proxy\->Proxy Settings命令。在手机端需要在访问网络时先连接代理服务器，也就是Charles应用

### <a id="_____606"></a><a id="_462"></a>要想通过Charles监听HTTPS数据，必须在PC端和手机端安装证书

### <a id="_____608"></a><a id="_463"></a>Charles有一个重要特性是可以重复发送请求

## <a id="_____610"></a><a id="_451"></a>2、使用mitmproxy

### <a id="_____612"></a><a id="_464"></a>mitmproxy是一个支持HTTP和HTTPS的抓包程序，功能与Charles类似，只不过mitmproxy是一个控制台程序，操作都需要在控制台完成

### <a id="_____614"></a><a id="_465"></a>mitmproxy有两个关联组件：mitmdump和mitmweb

### <a id="_____616"></a><a id="_466"></a>mitmproxy的主要功能如下：拦截HTTP和HTTPS请求和响应；保存HTTP回源，并进行分析；模拟客户端发起请求，模拟服务器返回响应；利用反向代理将浏览转发给指定的服务器；支持Mac和Linux上透明代理；利用Python对HTTP请求和响应进行实时代理

### <a id="_____618"></a><a id="_467"></a>mitmproxy可以通过命令行对截获的信息进行编辑，可以利用这个功能重新编辑请求

### <a id="_____620"></a><a id="_468"></a>mitmdump是mitmproxy的命令行接口，同时还可以对接Python对请求进行处理，这要比使用Charles方便不少

### <a id="_____622"></a><a id="_469"></a>mitmproxy有3种监听请求与响应的方式：mitmproxy控制台方式；mitmdump与Python对接的方式；mitmweb可视化方式；

### <a id="_____624"></a><a id="_470"></a>通常会使用mitmweb分析请求和响应数据，而使用mitmdump与Python结合的方式抓取并处理数据

## <a id="_____626"></a><a id="_452"></a>3、项目实战：实时抓取“得到”App在线课程

# <a id="_____628"></a><a id="_122"></a>第17章 使用Appium在移动端抓取数据

## <a id="_____630"></a><a id="_450"></a>1、安装Appium

### <a id="_____632"></a><a id="_471"></a>Appium桌面端支持全平台安装，而且提供源代码

### <a id="_____634"></a><a id="_472"></a>AppImage是一种通用的Linux安装程序，在传统的Linux安装程序中，不同发行版本会使用不同类型的安装程序

## <a id="_____636"></a><a id="_453"></a>2、Appium的基本使用方法

### <a id="_____638"></a><a id="_473"></a>获取App的appPackage至少有2种方式：利用手机本身的功能；从AndroidManifest\.xml文件中获得Package

## <a id="_____640"></a><a id="_454"></a>3、使用Python控制手机

## <a id="_____642"></a><a id="_455"></a>4、AppiumPythonClient Api

### <a id="_____644"></a><a id="_474"></a>可以使用Selenium中差值方法来实现对App中UI元素的查找，推荐使用ID查找

### <a id="_____646"></a><a id="_475"></a>单击元素可以使用tap方法，该方法可以模拟手指点击动作，支持多指触摸

### <a id="_____648"></a><a id="_476"></a>可以使用scroll方法模拟屏幕滚动

### <a id="_____650"></a><a id="_477"></a>可以使用swipe方法模拟从A点滑动到B点

### <a id="_____652"></a><a id="_478"></a>使用drag\_and\_drop方法可以将某一个元素拖拽到另一个目标元素上

### <a id="_____654"></a><a id="_479"></a>使用set\_text方法和send\_keys方法都可以实现文本输入

### <a id="_____656"></a><a id="_480"></a>与Senium中的ActionChains类似，Appium中的TouchAction可支持的方法包括tap、press、long\_press、release、move\_to、cancel、wait等

## <a id="_____658"></a><a id="_456"></a>5、项目实战：利用Appium抓取微信朋友圈信息

# <a id="_____660"></a><a id="_123"></a>第18章 多线程和多进程爬虫

## <a id="_____662"></a><a id="_302"></a>1、线程与进程

### <a id="_____664"></a><a id="_310"></a>只有可执行程序被调入内存中才叫进程

### <a id="_____666"></a><a id="_311"></a>每个进程都拥有自己的地址空间、内存、数据栈以及其他用于跟踪执行的辅助数据

### <a id="_____668"></a><a id="_312"></a>进程可以派生（fork或spawn）新的进程来执行其他任务，不过由于每个新进程也都拥有自己的内存和数据栈等

### <a id="_____670"></a><a id="_313"></a>线程是在同一个进程下执行的，并共享同一个上下文

### <a id="_____672"></a><a id="_314"></a>线程属于进程，而且线程必须依赖进程才能执行。一个进程可以包含一个或多个线程

### <a id="_____674"></a><a id="_315"></a>线程包括开始、执行和结束三部分

### <a id="_____676"></a><a id="_316"></a>一个进程中的各个线程与主进程共享同一块数据空间

### <a id="_____678"></a><a id="_317"></a>要注意的是，线程的执行时间是不平均的

## <a id="_____680"></a><a id="_303"></a>2、Python与线程

### <a id="_____682"></a><a id="_318"></a>Python多线程在底层使用了兼容POSIX的线程，也就是众所周知的pthread

### <a id="_____684"></a><a id="_319"></a>要注意的是，在Python2\.x中这个模块叫thread，从Python3\.x开始，thread更名为\_thread

### <a id="_____686"></a><a id="_320"></a>锁并不是将程序锁住不退出，而是通过锁可以让程序了解是否还有线程函数没执行完，而且可以做到当所有的线程函数执行完后，程序会立刻退出，而无须任何等待

## <a id="_____688"></a><a id="_304"></a>3、高级线程模块

### <a id="_____690"></a><a id="_321"></a>在threading模块中有一个非常重要的Thread类，该类的实例表示一个执行线程的对象

### <a id="_____692"></a><a id="_322"></a>\_thread模块可以看作线程的面向过程版本，而Thread类可以看作线程的面向对象版本

### <a id="_____694"></a><a id="_323"></a>Thread类构造方法的target关键字参数不仅可以是一个函数，还可以是一个对象，可以称这个对象为线程对象

### <a id="_____696"></a><a id="_324"></a>从Thread类继承最简单的方式是在子类的构造方法中通过super\(\)函数调用父类的构造方法，并传入相应的参数值

## <a id="_____698"></a><a id="_305"></a>4、线程同步

### <a id="_____700"></a><a id="_325"></a>线程锁的目的是将一段代码锁住，一旦获得了锁权限，除非释放线程锁，否则其他任何代码都无法再次获得锁权限

### <a id="_____702"></a><a id="_326"></a>信号量是最古老的同步原语之一，它是一个计数器，用于记录资源消耗情况

### <a id="_____704"></a><a id="_327"></a>要注意的是信号量对象的acquire方法与release方法

## <a id="_____706"></a><a id="_306"></a>5、生产者\-\-消费者问题与queue模块

## <a id="_____708"></a><a id="_307"></a>6、多进程

### <a id="_____710"></a><a id="_328"></a>可以使用multiprocessing模块的进程池（Pool类），通过Pool类构造方法的processes参数，然后指定创建的进程数

## <a id="_____712"></a><a id="_308"></a>7、项目实战：抓取豆瓣音乐Top250排行榜（多线程版）

## <a id="_____714"></a><a id="_309"></a>8、项目实战：抓取豆瓣音乐Top250排行榜（多进程版）

# <a id="_____716"></a><a id="_124"></a>第19章 网络爬虫框架：Scrapy

## <a id="_____718"></a><a id="_428"></a>1、Scrapy基础知识

### <a id="_____720"></a><a id="_431"></a>通过Scrapy框架，可以非常轻松的实现强大的爬虫系统。

### <a id="_____722"></a><a id="_432"></a>外围的工作，如抓取页面、保存数据、任务调度、分布式等，直接交给Scrapy就可以了

### <a id="_____724"></a><a id="_433"></a>包括6个部分：Scrapy Engine（Scrapy引擎）：用来处理整个系统的数据流，触发各种事件；Scheduler（调度器）：从URL队列中取出一个URL；Downloader（下载器）：从Internet上下载Web资源；Spiders（网络爬虫）：接收下载器下载的原始数据，做进一步处理；Item Pipeline（项目管道）：接收网络爬虫传过来的数据，以便做进一步处理；中间件：整个Scrapy框架有很多中间件，如下载器中间件、网络爬虫中间件等

### <a id="_____726"></a><a id="_434"></a>整个流程图中，整体在Scrapy Engine的调度下，首先运行的是Scheduler，Scheduler从下载队列中取一个URL，将这个URL交给Downloader，Downloader下载这个URL对应的Web资源，然后将下载的原始数据交给Spiders，Spiders会从原始数据中提取出有用的信息，最后将提取出来的数据交给Item Pipeline，可以通过Item Pipeline将数据保存到数据库、文本文件或其他存储介质上

### <a id="_____728"></a><a id="_435"></a>Scrapy提供了一个Shell，相当于Python的REPL环境

### <a id="_____730"></a><a id="_436"></a>Scrapy主要是使用XPath过滤HTML页面的内容

## <a id="_____732"></a><a id="_429"></a>2、用Scrapy编写网络爬虫

### <a id="_____734"></a><a id="_437"></a>Scrapy框架提供了一个scrapy命令用来建立Scrapy工程

### <a id="_____736"></a><a id="_438"></a>PyCharm不支持建立Scrapy工程

### <a id="_____738"></a><a id="_439"></a>PyCharm扩展工具允许在PyCharm中通过单击命令执行外部命令

### <a id="_____740"></a><a id="_440"></a>parse方法的返回值会被传给Item Pipeline，并由相应的Item Pipeline将数据保存成相应格式的文件。parse方法的返回值类型必须是scrapy\.Item或其scrapy\.Item的子类。

### <a id="_____742"></a><a id="_441"></a>本质上，ItemLoader对象也是通过返回一个item的方式保存数据的，只不过ItemLoader对象将item和reponse进行了封装

### <a id="_____744"></a><a id="_442"></a>转换的基本原理是将CSV格式的文件作为数据源来读取，然后在parse方法中将CSV文件中的数据通过Item转换为指定的格式，如JSON格式

## <a id="_____746"></a><a id="_430"></a>3、Scrapy的高级应用

### <a id="_____748"></a><a id="_443"></a>Scrapy允许使用中间件干预数据的抓取过程，以及完成其他数据处理工作

### <a id="_____750"></a><a id="_444"></a>Scrapy提供了很多内建的下载器中间件，例如下载超时、自动重定向、设置默认HTTP请求头等

### <a id="_____752"></a><a id="_445"></a>爬虫中间件会在3个位置起作用：向服务器发送Request之前；在Downloader生成Response并发送Spider之前；在Spider生成Item并发送给Item管道之前

### <a id="_____754"></a><a id="_446"></a>Item管道的主要功能如下：数据清理，主要清理HTML数据；校验抓取的数据，检查抓取的字段数据；查重并丢弃重复的内容；数据存储；

### <a id="_____756"></a><a id="_447"></a>CrawlSpider是Scrapy提供的一个通用爬虫

### <a id="_____758"></a><a id="_448"></a>一些内置的处理器：Identity最简单的Processor；TakeFirst返回列表的第一个非空值；Join处理器用于将列表中每个元素首尾相接合成一个字符串；Compose处理器允许将多个处理器或函数组成在一起使用；MapCompose可以迭代处理一个列表输入值；SelectJmes可以通过key获得JSON对象的value

# <a id="_____760"></a><a id="_125"></a>第20章 综合爬虫项目：可视化爬虫

