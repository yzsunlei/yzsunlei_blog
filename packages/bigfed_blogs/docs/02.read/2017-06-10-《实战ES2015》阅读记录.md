---
layout: post
title: 《实战ES2015》阅读记录
category: 阅读
tag: ES6
exception: 《实战ES2015》一书以清晰的思路讲解了ES2015的详细特性和意义，并以两个实际案例展示了利用ES2015中的特性如何提高应用的前端和后端的开发速度和工程化模式，很值得一读
readtime: 15
---

# 概述
* 12-factor规则
* 组件化是模块化开发的高级体现
* 虚拟滚动视图?在IOS等原生开发环境中，虚拟滚动视图是被底层所实现的
* ES只有变量而没有常量的设计很容易导致内存不安全、数据丢失或被恶意篡改
* const可以实现变量名与内存地址的强绑定
* ES2015为实际开发所带来的意义：语法糖、模块化、组件化开发等工程化优势
* 严格模式？可选择的一个限制JavaScript的变体的一种方式、不仅仅是一个子集、消除了一些JavaScript的静默错误，通过改变他们来抛出错误、
修复了JavaScript引擎难以执行优化的错误，可以比非严格模式相同代码执行的更快、禁用了在ECMAscript的未来版本中可能会定义的一些语法

# 新语法
* 新语法中影响最为直接、范围最大的要数let和const了
* 原生绑定事件方法addEventListener的第三个参数，Boolean值的作用？
* var可以让同一个变量名在同一个作用域里被定义多次，let不行
* const的原理是在变量名与内存地址之间建立不可变的绑定，当后面的程序尝试申请新的内存空间时，引擎便会抛出错误
* 一个变量（或常量）的生命周期模式是固定的，由作用域和对其的引用两种因素决定的，如果要把一个变量的生命周期延长，最为常用的方法便是闭包
* 新的循环语句for..of，主要用途是代替for..in循环语句
* Array.forEach方法的特点便是自带闭包，以解决因为缺乏块级作用域导致需要使用取巧的方法来解决var的作用域问题
* 在箭头函数中没有arguments、callee和caller等对象
* 开发者允许直接向一个对象字面量注入__proto__，使其直接成为类的一个实例
* 可动态计算的属性名：直接使用一个表达式来表达一个属性名，这个特性在某种意义上是为后面的Symbol而准备的
* 模式匹配实现swap：`[foo, bar] = [bar, foo]`
* ECMAScript的函数没有重载的概念，即无法通过不同的参数列表来区分同一个函数名的不同作用（默认参数值很友好）
* 在严格模式中，arguments.callee和arguments.caller是禁止被使用的
* WeakSet最大的实用意义在于，可以直接对引擎中垃圾收集器的运行情况有程序化的探知方式，开发者可以利用WeakSet的特性以更高的定制化方案优化程序的内存使用方案
* Map对象和Object对象的区别：使用任意对象作为键，可以方便的得知键值对的数量
* JavaScript还是没有原生类机制的
* ES2015的类语法中，原本的构造函数被类的constructor方法代替，而其余需要定义在prototype中的方法则可以直接定义在class中
* 在类中定义的方法，都是带有作用域的普通函数，而不是箭头函数
* 父类必须在子类定义之前被定义
* 遗憾与期望：不支持私有属性、不支持实例属性、不支持多重继承、没有类似于协议和接口等的概念
* 从计算机科学角度上说，生成器是一种类协程或半协程，他提供一种可以通过特定语句或方法使其执行对象暂停的功能
* yield*与yield的区别在于，它的功能是将一个生成器对象嵌套在另一个生成器内，并将其展开
* 回调地狱(Callback Hell)
* 第三方库co，它的意义在于利用生成器来模拟协程
* Promise在设计上具有原子性，即只用三种状态：等待(Pending)、成功(Fulfilled)、失败(Rejected)
* Promise对象有两个用于处理Promise对象状态变化的方法（then和catch）
* Promise.all（iterable），所有对象都进入成功状态，会以一个可迭代对象来承载其中的所有返回值，其中一个进入了失败状态，则以那个进入失败状态的错误信息作为自己的错误信息
* TC-39定下了CommonJS、AMD、CMD或UMD等JavaScript模块化标准，RequireJS、SeaJS、FIS、Browserify、Webpack等模块加载库各占优势
* export语句后跟着的语句需要具有声明部分和赋值部分
* Symbol的实例值带有互不等价的特性，即任意两个Symbol值都不相等
* Symbol()函数可以接受一个除Symbol值以外的值作为该Symbol值的描述
* Symbol是一种值类型而非引用类型
* Symbol.for(key)会根据传入的key在全局作用域中注册一个Symbol值
* 元编程：一个程序可以对另外一个程序进行读取、转换，甚至在这第二个程序运行时对其进行修改，而在这个程序的内容、运行环境、配置等都不做任何修改
* Proxy提供的能力可以对任何对象的绝大部分行为进行拦截、监听和干涉，甚至实现更多的自定义程序行为
* Proxy通过设置行为监听方法来捕获程序对对应对象的行为，new Proxy(target, handler)，target为需要进行包装的目标对象，handler用于监听目标对象行为的监听器
* Proxy监听的对象也可以是函数，还可以是类用来监听其通过new语句来生产新实例的行为
* 只读化修饰？入侵式测试框架？
* 使用Proxy在定义方法和逻辑代码之间建立隔离层

# ES2016
* async/await
* Decorators（装饰器）
* 函数绑定

# 参考
* [ECMAScript 6 入门](http://es6.ruanyifeng.com/)
* [《实战ES2015》](https://book.douban.com/subject/26899930/)
* 书籍实例代码：[1、filmy](https://github.com/iwillwen/filmy) [2、duel-living](https://github.com/iwillwen/duel-living)